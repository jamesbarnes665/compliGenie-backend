# compligenie-backend/app/api/policies.py

from fastapi import APIRouter, HTTPException, Header, Depends
from typing import Optional, Dict, List
from datetime import datetime
import secrets
from pydantic import BaseModel
from app.models.partner import PolicyGeneration, PartnerTier
from app.services.policy_generator import PolicyGenerator
from app.services.pdf_generator import PDFGenerator
from app.services.partner_store import partner_store

# Define PolicyRequest here if it's not in models
class PolicyRequest(BaseModel):
    company_name: str
    industry: str
    state: str
    ai_tools: List[str]
    employee_count: int

router = APIRouter(prefix="/api/policies", tags=["policies"])
policy_generator = PolicyGenerator()
pdf_generator = PDFGenerator()

# Dependency to get current partner from API key (optional)
async def get_optional_partner(x_api_key: Optional[str] = Header(None)):
    if x_api_key:
        partner = partner_store.get_by_api_key(x_api_key)
        return partner
    return None

@router.post("/generate")
async def generate_policy(
    request: PolicyRequest,
    partner = Depends(get_optional_partner)
):
    """Generate an AI compliance policy"""
    try:
        # Generate the policy
        policy_content = policy_generator.generate_policy(request.dict())
        
        # Create policy ID
        policy_id = f"policy_{secrets.token_urlsafe(8)}"
        
        # Track partner revenue if API key was provided
        if partner:
            # Base price for policy generation
            base_price = 10.0
            
            # Calculate partner revenue based on tier
            partner_revenue = base_price * (partner.revenue_share_percentage / 100)
            
            # Create policy generation record
            policy_gen = PolicyGeneration(
                id=f"polgen_{secrets.token_urlsafe(8)}",
                partner_id=partner.id,
                policy_id=policy_id,
                company_name=request.company_name,
                industry=request.industry,
                employee_count=request.employee_count,
                base_price=base_price,
                partner_revenue=partner_revenue,
                created_at=datetime.utcnow()
            )
            
            # Update partner stats
            partner.policies_generated_total += 1
            partner.policies_generated_monthly += 1
            partner.total_revenue += base_price
            partner.monthly_revenue += base_price
            partner.pending_payout += partner_revenue
            partner.last_policy_date = datetime.utcnow()
            
            # Check for tier upgrade
            if partner.policies_generated_monthly > 200 and partner.tier != PartnerTier.ENTERPRISE:
                partner.tier = PartnerTier.ENTERPRISE
                partner.revenue_share_percentage = 40
            elif partner.policies_generated_monthly > 50 and partner.tier == PartnerTier.STARTER:
                partner.tier = PartnerTier.GROWTH
                partner.revenue_share_percentage = 30
            
            # Save updates
            partner_store.update(partner.id, partner.dict())
            
            # Log the revenue tracking
            print(f"Policy generated by partner {partner.id}")
            print(f"Revenue tracked: ${base_price}, Partner share: ${partner_revenue}")
        
        # Generate PDF
        pdf_content = pdf_generator.generate_pdf(policy_content)
        
        return {
            "policy_id": policy_id,
            "policy_type": policy_content.get("policy_type", "AI Usage Policy"),
            "company_name": request.company_name,
            "generated_at": datetime.utcnow().isoformat(),
            "policy_content": policy_content,
            "pdf_url": f"/api/policies/{policy_id}/download",
            "partner_tracked": partner is not None
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/{policy_id}/download")
async def download_policy(policy_id: str):
    """Download policy as PDF"""
    # This would retrieve and return the PDF
    return {"message": "PDF download endpoint", "policy_id": policy_id}
